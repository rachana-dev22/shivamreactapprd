{
  "version": 3,
  "sources": ["../asset-server-worker/src/index.ts", "../asset-server-worker/src/assets-manifest.ts", "../asset-server-worker/src/responses.ts", "../asset-server-worker/src/constants.ts", "../asset-server-worker/src/utils/headers.ts", "../asset-server-worker/src/utils/kv.ts"],
  "sourcesContent": ["import { WorkerEntrypoint } from \"cloudflare:workers\";\nimport { AssetsManifest } from \"./assets-manifest\";\nimport {\n\tInternalServerErrorResponse,\n\tMethodNotAllowedResponse,\n\tNotFoundResponse,\n\tOkResponse,\n} from \"./responses\";\nimport { getAdditionalHeaders, getMergedHeaders } from \"./utils/headers\";\nimport { getAssetWithMetadataFromKV } from \"./utils/kv\";\n\nexport default class extends WorkerEntrypoint<Env> {\n\tasync fetch(request: Request) {\n\t\tif (request.method.toLowerCase() !== \"get\") {\n\t\t\treturn new MethodNotAllowedResponse();\n\t\t}\n\n\t\ttry {\n\t\t\treturn this.handleRequest(request);\n\t\t} catch (err) {\n\t\t\treturn new InternalServerErrorResponse(err);\n\t\t}\n\t}\n\n\tasync handleRequest(request: Request) {\n\t\tconst assetEntry = await this.getAssetEntry(request);\n\t\tif (!assetEntry) {\n\t\t\treturn new NotFoundResponse();\n\t\t}\n\n\t\tconst assetResponse = await getAssetWithMetadataFromKV(\n\t\t\tthis.env.ASSETS_KV_NAMESPACE,\n\t\t\tassetEntry\n\t\t);\n\n\t\tif (!assetResponse || !assetResponse.value) {\n\t\t\tthrow new Error(\n\t\t\t\t`Requested asset ${assetEntry} exists in the asset manifest but not in the KV namespace.`\n\t\t\t);\n\t\t}\n\n\t\tconst { value: assetContent, metadata: assetMetadata } = assetResponse;\n\t\tconst additionalHeaders = getAdditionalHeaders(\n\t\t\tassetEntry,\n\t\t\tassetMetadata,\n\t\t\trequest\n\t\t);\n\t\tconst headers = getMergedHeaders(request.headers, additionalHeaders);\n\n\t\treturn new OkResponse(assetContent, { headers });\n\t}\n\n\tprivate async getAssetEntry(request: Request) {\n\t\tconst url = new URL(request.url);\n\t\tlet { pathname } = url;\n\n\t\tconst assetsManifest = new AssetsManifest(this.env.ASSETS_MANIFEST);\n\t\tpathname = globalThis.decodeURIComponent(pathname);\n\n\t\treturn await assetsManifest.get(pathname);\n\t}\n}\n", "const HEADER_SIZE = 20;\nconst PATH_HASH_SIZE = 16;\nconst CONTENT_HASH_SIZE = 16;\nconst TAIL_SIZE = 8;\nconst ENTRY_SIZE = PATH_HASH_SIZE + CONTENT_HASH_SIZE + TAIL_SIZE;\n\nexport type AssetEntry = {\n\tpath: string;\n\tcontentHash: string;\n};\n\nexport class AssetsManifest {\n\tprivate data: ArrayBuffer;\n\n\tconstructor(data: ArrayBuffer) {\n\t\tthis.data = data;\n\t}\n\n\tasync get(pathname: string) {\n\t\t// encode pathname to match manifest encoding\n\t\tconst pathHash = await hashPath(pathname);\n\t\tconst entry = binarySearch(\n\t\t\tnew Uint8Array(this.data, HEADER_SIZE),\n\t\t\tpathHash\n\t\t);\n\t\treturn entry ? contentHashToKey(entry) : null;\n\t}\n}\n\nconst hashPath = async (path: string) => {\n\tconst encoder = new TextEncoder();\n\tconst data = encoder.encode(path);\n\tconst hashBuffer = await crypto.subtle.digest(\"SHA-256\", data.buffer);\n\treturn new Uint8Array(hashBuffer, 0, PATH_HASH_SIZE);\n};\n\nconst binarySearch = (\n\tarr: Uint8Array,\n\tsearchValue: Uint8Array\n): Uint8Array | false => {\n\tif (arr.byteLength === 0) {\n\t\treturn false;\n\t}\n\tconst offset =\n\t\tarr.byteOffset + ((arr.byteLength / ENTRY_SIZE) >> 1) * ENTRY_SIZE;\n\tconst current = new Uint8Array(arr.buffer, offset, PATH_HASH_SIZE);\n\tif (current.byteLength !== searchValue.byteLength) {\n\t\tthrow new TypeError(\n\t\t\t\"Search value and current value are of different lengths\"\n\t\t);\n\t}\n\tconst cmp = compare(searchValue, current);\n\tif (cmp < 0) {\n\t\tconst nextOffset = arr.byteOffset;\n\t\tconst nextLength = offset - arr.byteOffset;\n\t\treturn binarySearch(\n\t\t\tnew Uint8Array(arr.buffer, nextOffset, nextLength),\n\t\t\tsearchValue\n\t\t);\n\t} else if (cmp > 0) {\n\t\tconst nextOffset = offset + ENTRY_SIZE;\n\t\tconst nextLength = arr.buffer.byteLength - offset - ENTRY_SIZE;\n\t\treturn binarySearch(\n\t\t\tnew Uint8Array(arr.buffer, nextOffset, nextLength),\n\t\t\tsearchValue\n\t\t);\n\t} else {\n\t\treturn new Uint8Array(arr.buffer, offset, ENTRY_SIZE);\n\t}\n};\n\nconst compare = (a: Uint8Array, b: Uint8Array) => {\n\tif (a.byteLength < b.byteLength) {\n\t\treturn -1;\n\t}\n\tif (a.byteLength > b.byteLength) {\n\t\treturn 1;\n\t}\n\n\tfor (const [i, v] of a.entries()) {\n\t\tif (v < b[i]) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (v > b[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n};\n\nconst contentHashToKey = (buffer: Uint8Array) => {\n\tconst contentHash = new Uint8Array(\n\t\tbuffer,\n\t\tbuffer.byteOffset + PATH_HASH_SIZE\n\t).slice(0, CONTENT_HASH_SIZE);\n\treturn [...contentHash].map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n};\n", "export class OkResponse extends Response {\n\tconstructor(body: BodyInit | null, init?: ResponseInit) {\n\t\tsuper(body, {\n\t\t\t...init,\n\t\t\tstatus: 200,\n\t\t});\n\t}\n}\n\nexport class NotFoundResponse extends Response {\n\tconstructor(...[body, init]: ConstructorParameters<typeof Response>) {\n\t\tsuper(body, {\n\t\t\t...init,\n\t\t\tstatus: 404,\n\t\t\tstatusText: \"Not Found\",\n\t\t});\n\t}\n}\n\nexport class MethodNotAllowedResponse extends Response {\n\tconstructor(...[body, init]: ConstructorParameters<typeof Response>) {\n\t\tsuper(body, {\n\t\t\t...init,\n\t\t\tstatus: 405,\n\t\t\tstatusText: \"Method Not Allowed\",\n\t\t});\n\t}\n}\n\nexport class InternalServerErrorResponse extends Response {\n\tconstructor(err: Error, init?: ResponseInit) {\n\t\tsuper(undefined, {\n\t\t\t...init,\n\t\t\tstatus: 500,\n\t\t});\n\t}\n}\n\nexport class NotModifiedResponse extends Response {\n\tconstructor(...[_body, _init]: ConstructorParameters<typeof Response>) {\n\t\tsuper(undefined, {\n\t\t\tstatus: 304,\n\t\t\tstatusText: \"Not Modified\",\n\t\t});\n\t}\n}\n", "// have the browser check in with the server to make sure its local cache is valid before using it\nexport const CACHE_CONTROL_BROWSER = \"public, max-age=0, must-revalidate\";\n", "import { CACHE_CONTROL_BROWSER } from \"../constants\";\nimport type { AssetMetadata } from \"./kv\";\n\n/**\n * Returns a Headers object that is the union of `existingHeaders`\n * and `additionalHeaders`. Headers specified by `additionalHeaders`\n * will override those specified by `existingHeaders`.\n *\n */\nexport function getMergedHeaders(\n\texistingHeaders: Headers,\n\tadditionalHeaders: Headers\n) {\n\tconst mergedHeaders = new Headers(existingHeaders);\n\tfor (const [key, value] of additionalHeaders) {\n\t\t// override existing headers\n\t\tmergedHeaders.set(key, value);\n\t}\n\n\treturn mergedHeaders;\n}\n\n/**\n * Returns a Headers object that contains additional headers (to those\n * present in the original request) that the Assets Server Worker\n * should attach to its response.\n *\n */\nexport function getAdditionalHeaders(\n\tassetKey: string,\n\tassetMetadata: AssetMetadata | null,\n\trequest: Request\n) {\n\tlet contentType = assetMetadata?.contentType ?? \"application/octet-stream\";\n\tif (contentType.startsWith(\"text/\") && !contentType.includes(\"charset\")) {\n\t\tcontentType = `${contentType}; charset=utf-8`;\n\t}\n\n\tconst headers = new Headers({\n\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\"Content-Type\": contentType,\n\t\t\"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n\t\t\"X-Content-Type-Options\": \"nosniff\",\n\t\tETag: `${assetKey}`,\n\t});\n\n\tif (isCacheable(request)) {\n\t\theaders.append(\"Cache-Control\", CACHE_CONTROL_BROWSER);\n\t}\n\n\treturn headers;\n}\n\nfunction isCacheable(request: Request) {\n\treturn !request.headers.has(\"authorization\") && !request.headers.has(\"range\");\n}\n", "export type AssetMetadata = {\n\tcontentType: string;\n};\n\nexport async function getAssetWithMetadataFromKV(\n\tassetsKVNamespace: KVNamespace,\n\tassetKey: string,\n\tretries = 1\n) {\n\tlet attempts = 0;\n\n\twhile (attempts <= retries) {\n\t\ttry {\n\t\t\treturn await assetsKVNamespace.getWithMetadata<AssetMetadata>(assetKey, {\n\t\t\t\ttype: \"stream\",\n\t\t\t\tcacheTtl: 31536000, // 1 year\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (attempts >= retries) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Requested asset ${assetKey} could not be fetched from KV namespace.`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Exponential backoff, 1 second first time, then 2 second, then 4 second etc.\n\t\t\tawait new Promise((resolvePromise) =>\n\t\t\t\tsetTimeout(resolvePromise, Math.pow(2, attempts++) * 1000)\n\t\t\t);\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["WorkerEntrypoint", "AssetsManifest", "data", "pathname", "pathHash", "hashPath", "entry", "binarySearch", "contentHashToKey", "path", "hashBuffer", "arr", "searchValue", "offset", "current", "cmp", "compare", "nextOffset", "nextLength", "a", "b", "i", "v", "buffer", "OkResponse", "body", "init", "NotFoundResponse", "MethodNotAllowedResponse", "InternalServerErrorResponse", "err", "CACHE_CONTROL_BROWSER", "getMergedHeaders", "existingHeaders", "additionalHeaders", "mergedHeaders", "key", "value", "getAdditionalHeaders", "assetKey", "assetMetadata", "request", "contentType", "headers", "isCacheable", "CACHE_CONTROL_BROWSER", "getAssetWithMetadataFromKV", "assetsKVNamespace", "assetKey", "retries", "attempts", "resolvePromise", "src_default", "WorkerEntrypoint", "request", "MethodNotAllowedResponse", "err", "InternalServerErrorResponse", "assetEntry", "NotFoundResponse", "assetResponse", "getAssetWithMetadataFromKV", "assetContent", "assetMetadata", "additionalHeaders", "getAdditionalHeaders", "headers", "getMergedHeaders", "OkResponse", "url", "pathname", "assetsManifest", "AssetsManifest"]
}
